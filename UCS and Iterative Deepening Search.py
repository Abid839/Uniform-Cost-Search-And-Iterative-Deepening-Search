# -*- coding: utf-8 -*-
"""Assignment-3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fe4lyMbp8Lj7UPMcDX4qWj1rphX5GMn-

###Uniform Cost Search
"""

from queue import PriorityQueue
import random
# Target grid
goal_state = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

# Valid moves
moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]

# Function to find the position of the blank space
def find_blank(grid):
    for r in range(3):
        for c in range(3):
            if grid[r][c] == 0:
                return r, c

# Check if a grid is the goal state
def is_goal(grid):
    return grid == goal_state

#generate random state
def generate_random_start_state():
    numbers = list(range(9))
    random.shuffle(numbers)
    return [numbers[i:i+3] for i in range(0, 9, 3)]

# Generate possible successor states
def generate_successors(state):
    successors = []  # List to store the generated successor states
    blank_row, blank_col = find_blank(state)  # Find the position of the blank space in the current state

    for dr, dc in moves:  # Iterate through valid moves (up, down, left, right)
        new_row, new_col = blank_row + dr, blank_col + dc  # Calculate the new position for the blank space

        if 0 <= new_row < 3 and 0 <= new_col < 3:  # Check if the new position is within the bounds of the grid
            new_state = [list(row) for row in state]  # Create a copy of the current state
            new_state[blank_row][blank_col], new_state[new_row][new_col] = new_state[new_row][new_col], new_state[blank_row][blank_col]  # Swap the blank space with the adjacent tile
            successors.append(new_state)  # Add the new state to the list of successors

    return successors  # Return the list of generated successor states


# Uniform Cost Search algorithm
def uniform_cost_search(start):
    priority_queue = PriorityQueue()  # Priority queue to manage states based on cost
    priority_queue.put((0, start, []))  # Add the start state to the queue with initial cost 0 and an empty path
    visited = set()  # Set to keep track of visited states
    total_states_generated = 0  # Counter to track the total number of states generated and expanded

    while not priority_queue.empty():
        cost, current, path = priority_queue.get()  # Get the state with the lowest cost from the queue

        if is_goal(current):  # Check if the current state is the goal state
            return path + [current], total_states_generated  # Return the solution path and the total states generated

        visited.add(tuple(map(tuple, current)))  # Add the current state to the visited set
        total_states_generated += 1  # Increment the total states generated counter

        for successor in generate_successors(current):  # Generate possible successor states
            if tuple(map(tuple, successor)) not in visited:  # Check if the successor state is not visited
                new_cost = cost + 1  # Calculate the new cost for the successor state
                new_path = path + [current]  # Extend the path with the current state
                priority_queue.put((new_cost, successor, new_path))  # Add the successor state to the queue with updated cost and path

    return None, total_states_generated  # If no solution is found, return None and the total states generated

#Example usage
# start_state = [
#     [2, 1, 6],
#     [3, 4, 8],
#     [5, 7, 0]
# ]
start_state = generate_random_start_state()
print("Start state:")
for row in start_state:
    print(row)
print("\n")

solution_path, states_generated = uniform_cost_search(start_state)

if solution_path:

    for step, state in enumerate(solution_path):
        print(f"Step {step}:")
        for row in state:
            print(row)
        print()
    print("Solution found!")
    print("Number of steps:", len(solution_path) - 1)
    print("Total states generated:", states_generated)
else:
    print("No solution found.")
    print("Total states generated:", states_generated)

"""###Iterative Deepening Search"""

import random

# Target grid
goal_state = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

# Valid moves
moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]

# Function to find the position of the blank space
def find_blank(grid):
    for r in range(3):
        for c in range(3):
            if grid[r][c] == 0:
                return r, c

# Check if a grid is the goal state
def is_goal(grid):
    return grid == goal_state

#generate random state
def generate_random_start_state():
    numbers = list(range(9))
    random.shuffle(numbers)
    return [numbers[i:i+3] for i in range(0, 9, 3)]

# Generate possible successor states
def generate_successors(state):
    successors = []
    blank_row, blank_col = find_blank(state)

    for dr, dc in moves:
        new_row, new_col = blank_row + dr, blank_col + dc

        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_state = [list(row) for row in state]
            new_state[blank_row][blank_col], new_state[new_row][new_col] = new_state[new_row][new_col], new_state[blank_row][blank_col]
            successors.append(new_state)

    return successors

# Depth-limited depth-first search
def depth_limited_search(state, depth_limit, path=[]):
    if depth_limit == 0:
        return None, 0

    if is_goal(state):
        return path + [state], 1

    blank_row, blank_col = find_blank(state)
    new_states = []

    for dr, dc in moves:
        new_row, new_col = blank_row + dr, blank_col + dc

        if 0 <= new_row < 3 and 0 <= new_col < 3:
            new_state = [list(row) for row in state]
            new_state[blank_row][blank_col], new_state[new_row][new_col] = new_state[new_row][new_col], new_state[blank_row][blank_col]
            new_states.append(new_state)

    total_states_explored = 0
    for new_state in new_states:
        result, states_explored = depth_limited_search(new_state, depth_limit - 1, path + [new_state])
        total_states_explored += states_explored

        if result is not None:
            return result, total_states_explored

    return None, total_states_explored

# Iterative Deepening Search
def iterative_deepening_search(start_state):
    depth_limit = 0

    while True:
        result, states_explored = depth_limited_search(start_state, depth_limit)

        if result is not None:
            return result, states_explored

        depth_limit += 1

# start_state = [
#     [2, 1, 6],
#     [3, 4, 8],
#     [5, 7, 0]
# ]
start_state = generate_random_start_state()

print("Start state:")
for row in start_state:
    print(row)
print("\n")

solution_path, states_explored = iterative_deepening_search(start_state)

if solution_path:

    for state in solution_path:
        for row in state:
            print(row)
        print()
    print("Solution found:")
    print("Number of steps:", len(solution_path) - 1)
    print("Total states explored:", states_explored)
else:
    print("No solution found.")

